# Types

# DB Message Types

type DBMessage {
  success: Boolean
  error: Boolean
  message: String
}
# User Types
type User {
  id: ID
  username: String
  active: Boolean
}

type PersonalInformation {
  id: ID
  dni: Int
  firstname: String
  lastname: String
  address: String
  phone: String
  email: String
}

# Invoice Types
type Invoice {
  id: ID
  number: Int
  type: InvoiceTypes
  dateEmit: String
  paymentType: PaymentTypes
  paid: Boolean
  note: String
  # user: User
  person: PersonalInformation
  products: [ProductInvoice]
}

type ProductInvoice {
  product: Product
  quantity: Int
}

type PersonInvoices {
  person: PersonalInformation
  invoices: [Invoice]
}

# Treasury Types
type BankAccount {
  id: ID
  name: String
  bank: String
  type: BankAccountTypes
  number: String
}

# Inventory Types
type Warehouse {
  id: ID
  name: String
  description: String
  active: Boolean
}

type Product {
  id: ID
  name: String
  price: Int
  quantity: Int
  description: String
  active: Boolean
  warehouse: Warehouse
}

# Enums

# Invoice Enums
enum InvoiceTypes {
  PURCHASE
  SALE
}

enum PaymentTypes {
  CASH
  TRANSFERENCE
}

# Treasury Enums
enum BankAccountTypes {
  CURRENT
  SAVING
}

# Inputs

# User Inputs
input UserInput {
  id: ID
  username: String!
  password: String!
}

input PersonalInformationInput {
  id: ID
  dni: Int!
  firstname: String!
  lastname: String!
  address: String!
  phone: String!
  email: String
}

# Invoice Inputs
input InvoiceInput {
  type: InvoiceTypes!
  paymentType: PaymentTypes!
  paid: Boolean!
  note: String
  person: InvoicePersonInput!
  products: [InvoiceProductInput!]
}

input InvoiceUpdateInput {
  paymentType: PaymentTypes!
  paid: Boolean!
  note: String
}

input InvoicePersonInput {
  id: ID
  dni: Int!
  firstname: String!
  lastname: String!
  address: String!
  phone: String!
  email: String
}

input InvoiceProductInput {
  product: ID!
  quantity: Int!
}

# Treasury Inputs
input BankAccountInput {
  id: ID
  name: String!
  bank: String!
  type: BankAccountTypes!
  number: String!
}

# Inventory Inputs
input WarehouseInput {
  id: ID
  name: String!
  description: String
  active: Boolean!
}

input ProductInput {
  id: ID
  name: String!
  price: Int!
  quantity: Int!
  description: String!
  active: Boolean!
  warehouse: ID!
}

type Query {
  # User
  getUser(id: ID!): User
  getUsers(limit: Int, offset: Int): [User]

  # PersonalInformation
  getPersonalInformation(id: ID!): PersonalInformation
  getPersonalInformations(limit: Int, offset: Int): [PersonalInformation]

  # Invoice
  getInvoice(id: ID!): Invoice
  getInvoices(limit: Int, offset: Int): [Invoice]

  # Client
  getClient(id: ID!): PersonInvoices
  getClients(limit: Int, offset: Int): [PersonalInformation]

  # BankAccount
  getBankAccount(id: ID!): BankAccount
  getBankAccounts(limit: Int, offset: Int): [BankAccount]

  # Warehouse
  getWarehouse(id: ID!): Warehouse
  getWarehouses(limit: Int, offset: Int): [Warehouse]

  # Product
  getProduct(id: ID!): Product
  getProducts(limit: Int, offset: Int): [Product]
}

type Mutation {
  # User
  newUser(input: UserInput!): DBMessage
  updateUser(input: UserInput!): DBMessage
  deleteUser(id: ID!): DBMessage

  # PersonalInformation
  updatePersonalInformation(input: PersonalInformationInput!): DBMessage

  # Invoice
  newInvoice(input: InvoiceInput!): DBMessage
  updateInvoice(input: InvoiceUpdateInput!): DBMessage
  deleteInvoice(id: ID!): DBMessage

  # BankAccount
  newBankAccount(input: BankAccountInput!): DBMessage
  updateBankAccount(input: BankAccountInput!): DBMessage
  deleteBankAccount(id: ID!): DBMessage

  # Warehouse
  newWarehouse(input: WarehouseInput!): DBMessage
  updateWarehouse(input: WarehouseInput!): DBMessage
  deleteWarehouse(id: ID!): DBMessage

  # Product
  newProduct(input: ProductInput!): DBMessage
  updateProduct(input: ProductInput!): DBMessage
  deleteProduct(id: ID!): DBMessage
}
